<h2 id="u3Ybw">考试内容：</h2>
1. 选择题 * 10： 定义 可能会涉及简单运算 不会涉及乘除法运算 符点数运算整张试卷不涉及；
2. 简答题：
    1. 组合逻辑电路（较为简单）
    2. 时序逻辑电路（较为重要）
3. 指令系统 && CPU（一道大综合题 包含很多个小问题）
    1. 指令系统的题一定要熟悉的掌握单周期和流水线的数据通路

> 附2021考试内容：
>

![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749181421649-135a5e82-39ed-412b-98f4-cbb0f1f4c5b3.png)

<h2 id="R3vOA">复习思路：</h2>
1. 相似题目参考作业；
2. 寻找样卷；

<h2 id="VFCqc">复习内容：</h2>
<h3 id="Kv7cl">数据的编码</h3>
<h4 id="Wtkhq">冯诺伊曼结构采用存储程序的工作方式</h4>
<h4 id="mIf6m">高级语言 （一对多） 汇编语言 （一对一） 机器语言</h4>
<h4 id="thmd3">原码 && 补码转换：</h4>
原码 <-> 补码：

1. 正数： 相同；
2. 负数： 除符号位， 按位取反， 末位加一；

> 几个特殊的补码：
>
> 11......1 -> -1
>
> 10.....0 -> -2^(n-1)
>

<h4 id="ta8YC">浮点数的表示：</h4>
<h5 id="OHJkk">浮点数的精度：</h5>
![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1746412469577-140bebd8-99cb-4686-ac3d-261e5a066d42.png)

> 浮点数的范围主要有阶码决定；
>
> 浮点数的精度主要由尾数决定；
>

<h5 id="i51SY">IEEE754：</h5>
![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1746412659705-63ce7e7e-a009-4a43-97db-6bc2f5ce37bc.png)

> 双精度浮点数的阶码为11位， 偏置常数为1023；
>

![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1746413448886-20d166d4-3e87-4a72-9725-6ca24cddd944.png)

> 非规格化数小数点前的一位从 1 变成 0 ；
>

<h3 id="lbAMu">数据的存储方式</h3>
<h4 id="BYfMv">大端存储 && 小端存储：</h4>
数据：  0x12345678 （高位 -> 低位： 0x12 0x34 0x56 0x78）

地址：  0x1000  0x1001  0x1002  0x1003

内容：  0x12    0x34    0x56    0x78 （大端）

内容：  0x78    0x56   0x34     0x12 （小端）

> 大端顺着存；
>
> 某个数据的地址是存放数据的最小地址；
>

<h3 id="NyKGR">数字逻辑基础</h3>
<h4 id="WE4op">CMOS</h4>
> 一对 CMOS 实现非门， 两对 CMOS 实现与非门、 或非门， 三对 CMOS 实现与门、或门；
>

<h4 id="KyJTS">真值表 <-> 逻辑表达式互相推导：</h4>
> A = 1 B = 1 C = 1
>
> 最小项： A * B * C
>
> 最大项： not(A) + not(B) + not(C)
>

<h4 id="DY6Oh"><font style="background-color:#2F4BDA;">卡诺图化简：</font></h4>
![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749823178032-786f1506-de9c-4747-87b4-9b3b8faefeb1.png)

> 化简规则：
>
> 1. 圈最少： 逻辑函数中，逻辑表达式的数量最少；
> 2. 圈最大： 每个逻辑表达式中出现的逻辑变元个数最少；
>

<h4 id="WC1hT">为了提高电路运行速度， 常利用“德摩根定律”将表达式转化为“与非”表达式进行电路实现</h4>
> 与非 && 非或 逻辑上等价；
>

<h3 id="JArfb">组合逻辑电路</h3>
<h4 id="R5f9F">组合逻辑的输出值仅依赖于当前的输入值</h4>
<h4 id="Z8wMu"><font style="background-color:#2F4BDA;">组合逻辑电路设计</font></h4>
> 组合逻辑可以放心使用无关项化简， 但是时序逻辑需要考虑电路是否可以自启动， 是否会出现挂起现象；
>

功能分析 -> 列出真值表 -> 使用卡诺图&&无关项化简 -> 写出对应的逻辑表达式 -> 画出电路图 -> 评价电路

<h4 id="sIpGj">典型组合逻辑部件（译码/编码器、多路选择/分配器、半加/全加器）</h4>
<h4 id="uqeSE"><font style="background-color:#2F4BDA;">组合逻辑定时分析</font></h4>
1. 传输延迟： 从输入端的信号变化开始到所有输出端得到最终稳定信号所经历的最长时间；
2. 最小延迟： 从输入端的信号变化开始到任一输出端开始产生变化所经历的最短时间；
3. 关键路径： 组合逻辑电路在输入和输出之间经历的最长路径；
4. 最短路径： 组合逻辑在输入和输出之间经历的最短路径；
5. 组合逻辑电路的传输延迟： 关键路径上所有原件的传输延迟之和；
6. 组合逻辑电路的最小延迟： 最短路径上所有原件的最小延迟之和；

<h3 id="oZWTG">时序逻辑电路</h3>
<h4 id="UOaSD">时序逻辑基本元件（掌握功能和符号）</h4>
<h5 id="IVxIt">SR锁存器</h5>
![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749892067414-abee542c-79ec-474d-9825-467f36791a57.png)

<h5 id="wd8Ym">D锁存器</h5>
![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749892185359-1889767c-5baa-434a-992f-a32900e939ac.png)

<h5 id="L7g1M"><font style="background-color:#2F4BDA;">D触发器</font></h5>
![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749892452353-ef164be0-6434-4955-a996-e65fa11b9b5d.png)

<h5 id="CVPJP">T触发器</h5>
![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749892649288-7787de7e-c9de-4802-b7d3-d57bf1509947.png)

<h4 id="XfsxP"><font style="background-color:#2F4BDA;">时序逻辑电路设计</font></h4>
功能分析 -> 画状态图和状态表 -> 状态化简和编码 -> 逻辑表达式 -> 画图 -> 电路评价 -> 未用状态分析

<h5 id="Qh7a0">状态图</h5>
![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749893063306-1f9cda4a-32e2-46ac-aa85-f22ce9e02ce5.png)![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749893161947-00a54e08-c585-4a38-95f5-5334d4f91230.png)

<h5 id="JxU0S">状态化简</h5>
![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749893505553-22886db5-fcd3-41d6-88ab-cd486cf692b0.png)

<h5 id="wUS8E">逻辑表达式</h5>
![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749895262324-3624ecc4-43e4-450e-8eae-e405ab1c8206.png)

<h5 id="UZaxF">画图</h5>
> 一定要将化简后的逻辑表达式与使用的时序逻辑部件的特征方程推导出最终的激励函数；
>

<h5 id="rr9Pb">未用状态分析</h5>
挂起：电路加电后进入未用状态， 且在未用状态间循环；

自启动：电路是否能在有限个时钟周期内进入工作状态， 且输出正确；

如何避免挂起时电路能够自启动：

出现挂起情况时， 要重新使用无关项化简， 避免因为引入不恰当的无关项导致挂起现象；

<h4 id="gF35A"><font style="background-color:#2F4BDA;">时序逻辑定时分析</font></h4>
![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749963405340-6e72d14c-092f-4fc4-a531-83f7f5b6a351.png)![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749963567903-25e1744b-2e35-43f8-8088-1903c75c6fee.png)

<h4 id="fBjNQ">典型时序逻辑部件（计数器、寄存器/通用寄存器组、移位寄存器）</h4>
<h3 id="lkfCE">存储器</h3>
![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749964061885-6ccc8861-6655-430c-b767-eb94c6a64bd2.png)![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749964311791-1677843e-8b4e-452e-ab54-8564f501a938.png)

<h3 id="w3oyK">运算部件设计</h3>
<h4 id="fRpzZ">并行进位加法器</h4>
![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749965766399-5d2f5ee7-d13a-4a7b-96ee-23a7f82fc172.png)

> P = X + Y 也可以， 对进位逻辑没有影响
>
> C(i + 1) = G(i + 1) + P(i + 1) * C(i)
>

<h4 id="mu840">标志位</h4>
![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749968024543-6dcf74a1-0461-44d8-99e3-777f77d82355.png)

进行减法时， 看作与减数的相反数的补码相加， 令 Cin = 1， 具体操作为直接将减数的所有位按位取反， 末位加一；

<h5 id="Jwsp9">整数减法</h5>
> 无符号整数减法对于“减数”仍然用补码运算实现， 只是对结果的解释按照无符号整数解释
>

<h6 id="SUetu">带符号数</h6>
1. 溢出判断：
    1. OF = 1
    2. 和的符号位和加数的符号位不同 （如果两个加数本来符号就不同， 结果一定不会溢出）
2. 做减法比较大小：
    1. OF == SF 且 ZF == 0（大于）

<h6 id="wLJYQ">无符号数</h6>
1. 溢出判断：
    1. CF  = 1 （加法为溢出， 减法为产生借位）
2. 做减法比较大小：
    1. CF = 0 且 ZF == 0（大于）

<h3 id="XtpBa"><font style="background-color:#2F4BDA;">乘法（不考竖式计算， 其余部分参考作业题）</font></h3>
<h4 id="YzUdr">无符号数乘法： 加法 + 逻辑右移</h4>
<h4 id="pdb7D">带符号数乘法：</h4>
1. 原码乘法：
    1. 乘积的符号由两个乘数的符号异或得到；
    2. 乘积的数值由两个乘数的数值进行无符号数乘法得到；
2. 补码乘法：
    1. Booth 's Algorithm： 加法 + 算术右移， 每一步加法的内容由当前位和上一位共同决定

![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1750087201389-cf2346a0-d008-4ffb-8be6-6153dad3e2f7.png)

<h4 id="eonPb">溢出判断：</h4>
1. 无符号数： 若高n位为零， 则不溢出， 否则溢出；
2. 带符号数： 若高n位全相同且等于“低n位的最高位”， 则不溢出；

<h3 id="u7YfM">除法</h3>
![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1750087271443-94341e7f-0fc2-4faa-b355-ca558b7b2e94.png)

<h3 id="AoeNP"><font style="background-color:#2F4BDA;">指令系统</font></h3>
> ![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749973343737-b54cd0e2-ff7b-4495-8ce9-5d85fb1d06a1.png)![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1750062862789-73f6eb64-f08d-40d3-865f-2e042f6cfbc9.png)
>

<h4 id="E5KHF">寻址方式</h4>
![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749974322895-804bfc8f-1dfd-4f8c-a072-276de50aa6db.png)

<h4 id="YRId0">指令设计风格</h4>
|  | CISC（复杂指令集计算机） | RISC（精简指令集计算机） |
| --- | --- | --- |
| 指令长度 | 变长操作码 && 变长指令字 | 定长操作码 && 定长指令字 |
| 指令数量与格式 | 指令数量多 && 指令格式多 | 指令数量少 && 指令格式少 |
| 寻址方式 | 寻址方式多 | 寻址方式少 |
| 指令周期 | 绝大多数指令需要多个时钟周期完成 | 采用流水线工作方式<br/>（指令周期短） |
| 存储器访问 | 除了专门的存储器读写指令外，<br/>运算指令也能访问存储器 | 只有 Load && Store 指令访问存储器，其余指令仅访问寄存器（RR方式） |
| 控制方式 | 采用微程序控制 | 采用组合逻辑电路控制，<br/>不用（少用）微程序控制 |
| 寄存器设计 | 有专用寄存器 | 采用大量通用寄存器 |
| 编译优化 | 难以通过编译优化生成高效目标代码 | 采用优化的编译系统 |


<h4 id="nJzc5">RTL规定（描述指令功能）</h4>
1. R[r]：	    	通用寄存器 r 中的内容；
2. M[addr]:	    	存储单元 addr 中的内容；
3. M[R[r]]：	    	寄存器 r 中的内容为存储单元 addr， addr中的内容；
4. PC：		    	PC 中的内容；
5. M[PC]： 	    	PC 中的内容为存储单元 addr， addr中的内容；
6. SEXT[imm]： 	对 imm 进行符号扩展；
7. ZEXT[imm]： 	对 imm 进行零扩展；
8. 传送方向“<-”： 	传送源在右， 传送目的在左；         

![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749986355914-9c923cf4-829d-4591-b904-51e18fcec13a.png)

<h3 id="NSvTt"><font style="background-color:#2F4BDA;">CPU</font></h3>
<h4 id="XztJC">CPI</h4>
> CPU执行时间 = 每个程序的时钟周期数      * 时钟周期
>
>  = 每个程序的指令条数 * 平均CPI * 时钟周期
>
> 对于某一条确定的指令， 其 CPI 是一个确定的值； 但是对于一个程序而言， 其 CPI 是一个平均值；
>

平均 CPI：

CPI = 程序需要的时钟周期数 / 指令条数

![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749985822342-c099242b-b151-42ad-a71e-639307e3f3d3.png)

<h4 id="iThx7">单周期数据通路</h4>
> 确定单周期 CPU 的时钟周期， 就是要寻找单周期 CPU 的关键路径， load 指令执行耗时最长， 以 load 指令的执行时间来确定时钟周期。
>

![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749986533985-7c3a1a83-381a-4f83-bf39-1ef7633b3aa6.png)

<h4 id="QlwvG">多周期与单周期性能对比</h4>
> ![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749987685076-fcb0a9b8-d389-4682-b9c6-83699c94a57b.png)
>

![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749987841906-b0fd7957-266e-46db-a2a2-3788eaf5ed26.png)

<h4 id="CSS8u">流水线数据通路</h4>
![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749988260989-236b316d-114f-4b5f-b190-561aa65c2e5a.png)![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1750087802056-a5e50445-2708-41c0-8282-56450f228dcb.png)

<h4 id="M1BwM">流水线冒险</h4>
<h5 id="TGUoj">结构冒险</h5>
> 同一个元件在同一时间被不同的指令使用；
>
> 解决方法： 增加实现相同功能的元件个数
>

<h5 id="ipgHn">数据冒险</h5>
<h6 id="JrEOV">阻塞 && 插入 NOP 指令</h6>
> 可以解决全部问题， 但是执行效率大大降低；
>

<h6 id="XkmKo">实现寄存器前半周期写， 后半周期读</h6>
> 可使 WB 周期对 RegFile 的写与 ID 周期对 RegFile 的读不冲突；
>

<h6 id="lHxB4">编译优化</h6>
> 不能解决所有数据冒险问题；
>
> 要求：
>
> 1. 优化后不产生新的冒险；
> 2. 保留原有指令的偏序关系不变；
>

<h6 id="THBzs">转发</h6>
> 不能解决 load-use 冒险；
>

<h6 id="UgV3b">最终实现方式</h6>
> 对非 load-use冒险使用转发，对 load-use冒险使用阻塞，并利用编译优化尽量降低出现 load-use冒险的概率
>

<h5 id="IJBiO">控制冒险</h5>
> 这里只针对 Beq 指令给出解决方案；
>
> 不解决 jal 指令；
>
> <font style="background-color:#2F4BDA;">异常和中断也是一种控制冒险；</font>
>

<h6 id="GzIVW">阻塞 && 插入 NOP 指令</h6>
> 可以解决全部问题， 但是执行效率大大降低；
>

<h6 id="wf3Ws">延迟分支（编译优化）</h6>
> 把与 Beq 无关的指令放在 Beq 的后 1 ....... n 条执行（n 取决于延迟损失时间片 C 的值）
>
> 与 beq 无关的指令：
>
> 1. 不使用 在 beq 中参与判断逻辑的寄存器的指令；
> 2. 不是跳转指令；
> 3. 不会改变程序跳转后可能使用的寄存器的值；
>

![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749993669048-6e87c63f-8dbc-4ca2-8a43-c5613a7eca79.png)

<font style="background-color:#2F4BDA;">注意编译优化后， 由于指令相对位置改变， beq 指令的立即数也会相应变化；</font>

<h6 id="pf5Fy">分支预测</h6>
> 如果判断 R[r1] == R[r2] 仍在 EX 周期执行， 则 ZERO 标志位会通过流水段寄存器送入 M 周期来实现在下一周期的跳转， 则在此之前已经有 3 条指令进入流水线， C= 3；
>
> 我们可以通过将判断 R[r1] == R[r2] 提前到 ID 阶段执行， 这样可以令 C = 1；
>

<h4 id="oRrzB">三种实现方式性能比较</h4>
![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749993783708-7bbb526d-e259-4ee1-928a-86e9f2c0ae60.png)![](https://cdn.nlark.com/yuque/0/2025/png/47151848/1749993798893-0be139c6-7a9d-455a-8857-a973aac6d671.png)

